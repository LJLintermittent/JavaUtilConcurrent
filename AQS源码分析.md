AQS为构建锁和同步器供了一些通用的功能实现，因此借助于AQS能简单且高效的构造出一些同步器，比如reentrantlock等这种独占式资源获取的同步器，以及Semaphore，countdownlatch等这种共享式的同步器

AQS的核心思想是如果被请求的资源是空闲状态，则将当前的请求线程设置为有效的工作线程，并且将共享资源的状态设置为锁定状态，如果被请求的共享资源被占用，那么就需要使用一套线程阻塞等待以及唤醒时锁分配的一种机制，这个机制就是由AQS的CLH队列来实现的，也就是说将获取不到锁的线程放到一个队列中。这个CLH队列是一个虚拟的双向队列，虚拟的意思是不存在这个队列的实例，仅存在节点之间的相关关系

总的来说AQS使用一个int型的成员变量来表示同步状态，通过内置的fifo队列来完成获取资源线程的排队工作，然后内部使用CAS来对这个同步状态进行更改

AQS定义了两种对资源的获取方式，一种是独占式，一种是共享式

独占式表示共享资源在同一时刻只能由一个线程进行操作，独占式又分为两种：

1.公平锁：按照线程在队列中的排队顺序，先到者先拿到锁

2.非公平锁：当线程想要获取锁的时候，先通过两次cas操作去抢锁，如果没抢到，会将当前线程加入到队列中等待唤醒

总结一下非公平锁和公平锁其实只有两处地方不同：

1.非公平锁在调用lock后，首先就会调用cas进行一次抢锁，如果这个时候恰巧锁没有被占用，那么就直接获取到锁然后返回

2.如果在第一次cas失败后，和公平锁一样会进入到tryacquire方法，在这个方法中，如果发现这个时候state==0了，也就是说锁被释放了，非公平锁又会开始一次cas抢锁，但是公平锁会判断等待队列里面是否有线程正在等待，如果有线程（Node节点），那么公平锁会自己乖乖的到队列末尾排队

注意到非公平锁其实比公平锁多了两次cas操作，但是如果两次cas都失败了，那么后面就跟公平锁一样，都要进入队列进行等待