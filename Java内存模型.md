在java中，所有实例域，静态域和数组元素都存储在堆内存中，堆内存在线程之间是共享的，我们常说的共享变量就是指的实例域，静态域，局部变量，方法定义参数，异常处理器参数不会在线程之间共享，他们不会有内存可见性问题，也不受到内存模型的影响

#### 硬件的效率和一致性

对于让计算机并发的执行任务，更充分的利用计算机处理器的性能这一点，处理器要解决的不仅是运算，还需要与内存交互，如读取计算数据，存储计算结果等，这个io操作是无法避免的，由于计算机的处理器的处理速度和内存的读取写入速度还有着巨大的差距，所以现代计算机都不得不加入一层或多层读写速度尽可能接近处理器器的高速缓存，来作为内存与处理器之间的缓冲。那么加入了这个缓冲以后引入了新的问题，那就是缓存一致性的问题，因为多核处理器中，每个处理器核心都有自己的高速缓存，而他们又共享同一主内存，这种系统被称为共享内存多核系统，当多个处理器的运算任务都涉及同一块主内存区域时，那么会导致各自的缓存数据不一致，如果发生这种情况，那么同步回主内存的时候该以哪个高速缓存中的为准这是不确定的，所以各个处理器访问缓存需要遵守缓存一致性协议

同时为了使处理器内部的运算尽量能被充分利用，处理器可能会对输入的代码进行重排序，处理器虽然会保证乱序以后执行的结果与顺序执行的结果一致，但是会导致如果有依赖的操作，那么其顺序性不能依靠代码的先后顺序来保证

#### JMM内存模型

java内存模型的主要目的是定义程序中的各种变量的访问规则，关注的是虚拟机中把变量值存储到内存和从内存中取出变量这样的细节。这块的变量包括实例字段，静态字段和构成数组的元素，不包括局部变量和方法参数，因为局部变量和方法参数是线程私有的，在虚拟机栈中，不会被共享，自然不会出现竞争问题。

java内存模型规定了所有的变量都存储在主内存中，其实就是虚拟机中的一块内存，除此以外，每个线程都有自己的工作内存，工作内存可以跟计算机中的高速缓存对应起来，工作内存保存了该线程使用的主内存中的变量副本，线程对变量的所有操作（读取，赋值等）都必须在工作内存中完成，而不能直接读写主内存中的数据，并且不同的线程间也无法访问对方工作内存中的数据，另外呢，如果线程之间需要通信，那么对变量的传递都需要通过主内存来完成，所以线程，工作内存，协议，主内存构成了类似计算机系统中处理器，高速缓存，一致性协议，内存这样的模型。

#### 内存间的交互操作

关于主内存和工作内存之间具体的交互协议，即一个变量该如何从主内存拷贝到工作内存以及如果将工作内存同步回主内存的实现细节，在java内存模型中定义了八种操作来完成，java虚拟机实现时必须保证这八种操作都是原子的。

1.lock（锁定）：作用于主内存，把一个变量标识为一条线程独占的状态

2.unlock（解锁）：作用于主内存，把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定

3.read（读取）：作用于主内存的变量，把变量从主内存传输的线程的工作内存

4.load（载入）：作用于工作内存，把read操作读进来的变量值放到工作内存的变量副本中

5.use（使用）：作用于工作内存，把工作内存中的变量传递给执行引擎，由虚拟机执行需要使用变量值的字节码的时候会执行这个操作

6.assign（赋值）：作用于工作内存的变量，把一个从执行引擎中返回的值赋给工作内存的变量副本，也就是当虚拟机遇到需要给变量赋值的字节码的时候会执行这个操作

7.store（存储）：作用于工作内存，把工作内存中的一个变量的值传送给主内存中

8.write（写入）：作用于主内存，它把store操作从工作内存中得到的变量值放入到主内存的变量中

从主内存到工作内存的操作是read和load操作，从工作内存到主内存的操作是store和write，java内存模型规定对于这两个操作的顺序必须严格按顺序执行，但并不要求一定是连续的，也就是这两个操作之间可以插入其他的命令。

#### 有序性

java内存模型的有序性可以总结为一句话：如果在本线程内观察，那么所有操作都是有序的，如果在一个线程观察另一个线程，那么所有操作都是无序的。前半段指的是as if serial语义（线程内表现为串行），后半段指的是指令重排序现象和主内存与工作内存同步延迟的现象。

volatile本身就包含了禁止指令重排序的语义，而sync则是 一个变量在同一时刻只能允许一条线程对其进行lock操作这条规则获得的，这个规则决定了持有同一个锁的两个线程只能串行的进入

#### 先行发生原则

先行发生原则是判断数据是否存在竞争，线程是否安全的非常有用的手段，先行发生是java内存模型中定义的两项操作之间的偏序关系，比如说操作A先行发生于操作B，那么操作A产生的影响能被操作B观察到。

在java内存模型中有一些是天然的先行发生关系，这些先行发生关系无须任何同步器协助就已经存在，可以在代码中直接使用

1.程序次序规则：在一个线程内，按照控制流顺序，写在前面的操作一定先行发生于后面的操作，控制流顺序不是代码顺序，因为要考虑循环，分支等操作。

2.管程锁定规则：一个unlock操作先行发生于对后面对同一个锁的lock操作，注意必须是同一个锁

3.volatile变量规则：对一个volatile变量的写操作先行发生于后面对这个变量的写操作

4.线程启动规则：thread对象的start方法先行发生于此线程的每一个动作

5.线程终止规则：线程中的所有操作都先行发生于对此线程的终止检测，可以通过thread.join方法是否结束，thread.alive的返回值来检测一个线程是否终止

6.线程中断规则：对线程的interrupt方法的调用先行发生于被中断线程的代码检测到中断事件的发生

7.对象终结规则：一个对象的初始化完成先行发生于它的finalize方法的开始

8.传递性：如果操作A先行发生于操作B，操作B先行发生于操作C，那么可以得出操作A一定先行发生于操作C的结论

java语言对上面的这些操作无需使用任何同步手段

#### java线程的实现

以hotspot虚拟机为例，它的每一个java线程都是直接映射到一个操作系统原生线程来实现的，中间没有额外的间接结构，hotspot自己不会去干涉线程调度，虽然可以设置线程的优先级，但这不是一种稳定的方式，全权交给底下的操作系统去处理，所以何时冻结或者唤醒线程，该给线程分配多少处理器执行时间等问题都是由操作系统去完成。

#### java线程的调度

线程调度是指系统为线程分配处理器使用权的过程，线程调度的主要方式有两种，分别是协同式和抢占式。

协同式表示线程的执行时间由线程本身来控制，线程把自己的工作执行完了以后，要主动通知系统切换到另一个线程上去，协同式最大的好处就是实现简单，而且由于线程要把自己的事情干完才会进行线程切换，切换操作对线程自己是可知的，所以不会有同步问题

抢占式：多个线程将由系统来分配执行时间，线程的切换不由线程本身来决定

#### 线程的状态

java定义了6种线程状态，在任意一个时间点，一个线程只能有且一种状态

1.新建：线程创建后但没有启动，就是这种状态

2.运行：包括操作系统的running和ready，处于此种状态的线程可能正在运行，也可能正在等待操作系统给它分配执行时间

3.无期限等待（waiting）：处于这种状态的线程不会被分配处理器执行时间，他们需要等待其他线程显示地将其唤醒，如下方法会使线程刚进入无限期等待状态：

~~~wiki
1.没有设置timeout的object的wait方法

2.没有设置timeout的thread的join方法

3.locksupport的park方法
~~~

4.限期等待：处于这种状态的线程也不会被分配处理器的执行时间，但是无须等待被其他线程显示的唤醒，在一定时间后会自动唤醒

以下操作可能会使线程进入限期等待状态：

~~~wiki
1.thread.sleep
2.设置timeout的object的wait方法
3.设置timeout的thread的join方法
4.locksupport.parkUntil
5.locksupport.parkNanos
~~~

5.阻塞：线程被阻塞了，阻塞和等待的区别主要是阻塞状态在等待着获取到一个排它锁，当另外一个线程放弃这个锁的时候会立即去抢占锁，而等待状态是等待一段时间，或者唤醒动作的发生，在程序等待进入同步区域的时候，线程将进入这种状态

6.结束：已终止线程的线程状态，线程已经结束执行

#### reentrantlock

1.等待可中断：是指当前持有锁的线程长期不释放锁的时候，正在等待的线程可以选择放弃等待，改为处理其他事情，可中断特性对处理执行时间非常长的同步块很有帮助

2.公平锁：是指多个线程获取一个锁的时候，采用先来后到的顺序来获取锁，而非公平锁在释放锁的时候，所有正在等待的线程都有可能抢到锁，默认sync和reentrantlock都是非公平锁，reentrantlock可以使用公平锁模式，只不过如果使用公平锁，吞吐量会急剧下降

3.锁绑定多个条件：是指一个reentrantlock对象可以同时绑定多个condition对象，只需要多次调用newCondition()方法即可

在jdk1.6以后引入锁升级后，sync和reentrantlock的选择中性能已经不是主要因素了

#### 自旋锁

互斥同步对性能最大的影响就是阻塞的实现，挂起线程和恢复线程都需要切入到内核态，而这些操作给java虚拟机的并发性能带来很大的压力。为了解决这个问题，思路是对后面的线程不阻塞，也就是不需要切入内核态做挂起线程和恢复线程的操作，而是让线程进入一个忙等状态，这个状态的线程相当于一直在重试获取锁，自旋虽然避免了线程切换的开销，但是它要占用处理器的时间， 如果这个锁被占用的时间很短的话，那么自旋的效果是非常好的， 但是如果锁的时间非常长，自旋就会白白的消耗处理器的性能。

所以一般自旋锁都有一个自旋的次数，默认是10次，如果10次都没有成功获取到锁，那么还是走互斥的流程，在jdk6以后，引入了自适应自旋锁，意味着自旋的次数也不再是固定的了，而是由上一次在同一个锁上的自旋次数和当前锁的持有者状态来共同决定的

锁消除：

jvm通过逃逸分析技术对锁进行优化，如果进过逃逸分析后发现堆上的共享变量不会逃逸出该线程，那么也就不会发生线程不安全的问题，这个时候就可以把他们当做虚拟机栈上的数据来对待

