在java中，所有实例域，静态域和数组元素都存储在堆内存中，堆内存在线程之间是共享的，我们常说的共享变量就是指的实例域，静态域，局部变量，方法定义参数，异常处理器参数不会在线程之间共享，他们不会有内存可见性问题，也不受到内存模型的影响

#### 硬件的效率和一致性

对于让计算机并发的执行任务，更充分的利用计算机处理器的性能这一点，处理器要解决的不仅是运算，还需要与内存交互，如读取计算数据，存储计算结果等，这个io操作是无法避免的，由于计算机的处理器的处理速度和内存的读取写入速度还有着巨大的差距，所以现代计算机都不得不加入一层或多层读写速度尽可能接近处理器器的高速缓存，来作为内存与处理器之间的缓冲。那么加入了这个缓冲以后引入了新的问题，那就是缓存一致性的问题，因为多核处理器中，每个处理器核心都有自己的高速缓存，而他们又共享同一主内存，这种系统被称为共享内存多核系统，当多个处理器的运算任务都涉及同一块主内存区域时，那么会导致各自的缓存数据不一致，如果发生这种情况，那么同步回主内存的时候该以哪个高速缓存中的为准这是不确定的，所以各个处理器访问缓存需要遵守缓存一致性协议

同时为了使处理器内部的运算尽量能被充分利用，处理器可能会对输入的代码进行重排序，处理器虽然会保证乱序以后执行的结果与顺序执行的结果一致，但是会导致如果有依赖的操作，那么其顺序性不能依靠代码的先后顺序来保证

#### JMM内存模型

java内存模型的主要目的是定义程序中的各种变量的访问规则，关注的是虚拟机中把变量值存储到内存和从内存中取出变量这样的细节。这块的变量包括实例字段，静态字段和构成数组的元素，不包括局部变量和方法参数，因为局部变量和方法参数是线程私有的，在虚拟机栈中，不会被共享，自然不会出现竞争问题。

java内存模型规定了所有的变量都存储在主内存中，其实就是虚拟机中的一块内存，除此以外，每个线程都有自己的工作内存，工作内存可以跟计算机中的高速缓存对应起来，工作内存保存了该线程使用的主内存中的变量副本，线程对变量的所有操作（读取，赋值等）都必须在工作内存中完成，而不能直接读写主内存中的数据，并且不同的线程间也无法访问对方工作内存中的数据，另外呢，如果线程之间需要通信，那么对变量的传递都需要通过主内存来完成，所以线程，工作内存，协议，主内存构成了类似计算机系统中处理器，高速缓存，一致性协议，内存这样的模型。

#### 内存间的交互操作

关于主内存和工作内存之间具体的交互协议，即一个变量该如何从主内存拷贝到工作内存以及如果将工作内存同步回主内存的实现细节，在java内存模型中定义了八种操作来完成，java虚拟机实现时必须保证这八种操作都是原子的。

1.lock（锁定）：作用于主内存，把一个变量标识为一条线程独占的状态

2.unlock（解锁）：作用于主内存，把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定

3.read（读取）：作用于主内存的变量，把变量从主内存传输的线程的工作内存

4.load（载入）：作用于工作内存，把read操作读进来的变量值放到工作内存的变量副本中

5.use（使用）：作用于工作内存，把工作内存中的变量传递给执行引擎，由虚拟机执行需要使用变量值的字节码的时候会执行这个操作

6.assign（赋值）：作用于工作内存的变量，把一个从执行引擎中返回的值赋给工作内存的变量副本，也就是当虚拟机遇到需要给变量赋值的字节码的时候会执行这个操作

7.store（存储）：作用于工作内存，把工作内存中的一个变量的值传送给主内存中

8.write（写入）：作用于主内存，它把store操作从工作内存中得到的变量值放入到主内存的变量中

从主内存到工作内存的操作是read和load操作，从工作内存到主内存的操作是store和write，java内存模型规定对于这两个操作的顺序必须严格按顺序执行，但并不要求一定是连续的，也就是这两个操作之间可以插入其他的命令