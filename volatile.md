在多线程并发编程中，volatile是一种轻量级的synchronized，它在多处理的开发中保证了共享变量的可见性。可见性是当一个线程修改了某个共享变量的值，那么另一个线程总是能读到最新的值。

通过获取JIT编译器生成的汇编指令，查看volatile在并发写操作的时候发生了什么

可以了解到有一个lock前缀的指令，这个指令在多核处理器下会发生两件事情：

1.将当前处理器的缓存行的数据写回到系统内存

2.这个写回内存的操作会使其他cpu里缓存了该内存地址的数据无效

因为，为了提高处理速度，处理器不直接与内存打交道，而是先将系统内存的数据读取到cpu的高速缓存后再进行操作。但操作完不知道何时写回到内存中，如果对声明了volatile的变量进行写操作，jvm就会想处理器发送一条lock前缀的指令，将这个变量所在缓存行中的数据写回到系统内存，但是写回到系统内存，其他处理器的缓存行中的数据依旧是旧数据，所以，为了保证多核处理器各个缓存的一致性，推出了缓存一致性协议，当处理器发现自己缓存行中的数据的内存地址被修改了，就会将当前缓存行设置为无效状态，那么当处理器对这个数据进行修改操作的时候，就会从系统内存中读取最新的值到缓存行中

#### volatile的写读内存语义

当读一个volatile变量时，JMM会把该线程对应的工作内存中的数据置为无效状态，所以线程接下来需要去主内存读取共享变量

当写一个volatile变量时，JMM会把当前线程工作内存中的数据刷新到主内存中

为了实现volatile的这种内存语义，编译器需要在生成字节码的时候，在指令序列中插入内存屏障来限制特定类型的处理器重排序，对于编译器来说，他很难发现一个最优的，也就是最少数量的插入屏障的总数，为此，jmm采取保守策略：
1.在每个volatile写操作前面插入一个storestore屏障

2.在每个volatile写操作后面插入一个storeload屏障

3.每个volatile读前面插入一个loadload屏障

4.每个volatile读后面插入一个loadstore屏障

#### reentrantlock公平锁与非公平锁

公平锁与非公平锁在释放锁的时候都要写一个volatile变量state

公平锁获取的时候，首先去读volatile变量

非公平锁获取的时候，利用CAS更新volatile变量，CAS操作同时具有volatile读和volatile写的内存语义，因为CAS的源码中的cmpxchg会根据处理的核数来决定加不加lock前缀的指令，这个指令会禁止之前和之后的读和写的指令重排序，然后会把工作内存中的数据都写到主内存，并且使其他线程工作内存中的数据为无效